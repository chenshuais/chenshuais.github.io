<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://ian2018.cn/favicon.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="`Gmeek-html<img src='https://blog-image.ian2018.cn/images/86ff272f7ad726ad95ce92b6d9bb8137b55e2ea1.png'>`

通过之前的分享，我们已经知道了 Kotlin 的协程是什么，也知道了挂起函数。">
<meta property="og:title" content="Kotlin 协程中的 Job">
<meta property="og:description" content="`Gmeek-html<img src='https://blog-image.ian2018.cn/images/86ff272f7ad726ad95ce92b6d9bb8137b55e2ea1.png'>`

通过之前的分享，我们已经知道了 Kotlin 的协程是什么，也知道了挂起函数。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.ian2018.club/post/Kotlin%20-xie-cheng-zhong-de-%20Job.html">
<meta property="og:image" content="https://blog-image.ian2018.cn/avatar.webp">
<title>Kotlin 协程中的 Job</title>


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>
<style>#user-content-page_pv{color:red}#user-content-page_uv{color:red}</style>



<body>
    <div id="header">
<h1 class="postTitle">Kotlin 协程中的 Job</h1>
<div class="title-right">
    <a href="https://blog.ian2018.club" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><img src="https://blog-image.ian2018.cn/images/86ff272f7ad726ad95ce92b6d9bb8137b55e2ea1.png"></p>
<p>通过之前的分享，我们已经知道了 Kotlin 的协程是什么，也知道了挂起函数。今天就一块来学习一下什么是 <strong>Job</strong>。</p>
<h2>Job 从哪来</h2>
<p>平时我们使用协程，大部分都是直接 <code class="notranslate">launch</code> 一下就完了，很少的时候会用一下 <code class="notranslate">async</code>。</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">launch {
}
async { 
}
</code></pre>
<p>如果用过 <code class="notranslate">async</code> 的话，会发现 IDE 会有黄色的提醒，告诉你返回值 <strong>Deferred</strong> 没有使用。<br>
<img src="https://blog-image.ian2018.cn/images/cce0c7273f0b100ff9f5957cd51b7f5ae9386dc8.png"></p>
<p>这个 <strong>Deferred</strong> 其实就是 <strong>Job</strong>，它是一个继承 <strong>Job</strong> 的接口。<br>
<img src="https://blog-image.ian2018.cn/images/0f510aed293051cab6c231e17e9073fc6c46552c.png"></p>
<p>其实不止 <code class="notranslate">async</code> 有返回值，<code class="notranslate">launch</code> 也是有返回值的，而 <code class="notranslate">launch</code> 的返回值直接就是一个 <strong>Job</strong>。<br>
<img src="https://blog-image.ian2018.cn/images/4cff61b074c930a018498356a653c3262c27f8f1.png"></p>
<p>我们再来看一下 <strong>Job</strong> 的源码的定义（这里我删除了一些注释和内部 API）：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">public interface Job : CoroutineContext.Element {
    
    // ------------ state query ------------

    public val isActive: Boolean

    public val isCompleted: Boolean

    public val isCancelled: Boolean

    // ------------ state update ------------

    public fun start(): Boolean

    public fun cancel(cause: CancellationException? = null)

    // ------------ parent-child ------------

    public val children: Sequence&lt;Job&gt;

    // ------------ state waiting ------------

    public suspend fun join()

    // ------------ low-level state-notification ------------

    public fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle
    
}
</code></pre>
<p><strong>Job</strong> 的源码注释还是写的很清楚的，还贴心的做了划分。</p>
<p>从源码的注释我们可以大概知道，<strong>Job</strong> 大致分了五个部分：</p>
<ul>
<li>状态的查询</li>
<li>状态的更新</li>
<li>父子关系</li>
<li>状态的等待</li>
<li>状态监听</li>
</ul>
<p>这个状态其实就是协程的状态。</p>
<p>到这里我们已经知道了 <strong>Job</strong> 从哪来的，那么这个 <strong>Job</strong> 到底有什么用呢？接下来我们用几个例子来试一下。</p>
<h2>Job 有什么用</h2>
<p><img src="https://img.soogif.com/fCnkbyO30VyAxkMkMQMGzwWadCVCafE7.gif?scope=mdnice"><br>
在写例子之前，先做一下前置准备：</p>
<ol>
<li>给 IDEA 设置一下 VM 参数：<code class="notranslate">-Dkotlinx.coroutines.debug</code>，这样打印出来的线程名字中就包含了协程的信息。</li>
</ol>
<p><img src="https://blog-image.ian2018.cn/images/3a1ff93948b2260c5a0476ec4108ee40a7a22024.png"></p>
<ol start="2">
<li>log 打印方法：</li>
</ol>
<pre lang="kotlin" class="notranslate"><code class="notranslate">/**
 * 打印 Job 的状态信息，就是源码中看到的 state query 那部分内容
 */
fun Job.log() {
    logX(
        """
        isActive = $isActive
        isCancelled = $isCancelled
        isCompleted = $isCompleted
    """.trimIndent()
    )
}

/**
 * 控制台输出带协程信息的 log
 */
fun logX(any: Any?) {
    println(
        """
================================
$any
Thread:${Thread.currentThread().name}
================================""".trimIndent()
    )
}
</code></pre>
<h3>一、测试通过 Job 查看协程状态</h3>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test1() = runBlocking {
    val job = launch {
        delay(1000L)
    }
    job.log()             // ①
    delay(1500L)          // ②
    job.log()             // ③
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
isActive = false
isCancelled = false
isCompleted = true
Thread:main @coroutine#2
================================
</code></pre>
<p>上面代码中我们创建了一个协程，在里面做了一个延迟 1 秒钟的任务，然后马上通过 <strong>Job log</strong> 查看了一下当前协程的状态，发现 <strong>isActive</strong> 是 true，其他都是 false，说明当前协程属于活跃状态。</p>
<p>然后等了 1.5 秒后，再次通过 <strong>Job log</strong> 查看协程的状态，发现 <strong>isActive</strong> 变成了 false，并且 <strong>isCompleted</strong> 变成了 true。</p>
<p>通过这些我们大概就能知道 <strong>isActive</strong> 和 <strong>isCompleted</strong> 的状态啥时候会改变了吧，运行协程时 <strong>isActive</strong> 就是 true，等协程运行完成了，<strong>isCompleted</strong> 就变成了 true。</p>
<h3>二、测试通过 Job 更新协程状态</h3>
<h4>1. <strong>Job</strong> 的 <code class="notranslate">start</code> 方法</h4>
<p>要想使用 <code class="notranslate">start</code>，我们首先得改一下 <code class="notranslate">launch</code> 的启动方式：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test2() = runBlocking {
    //                           变化在这里
    //                               ↓
    val job = launch(start = CoroutineStart.LAZY) {
        logX("Coroutine start!")
        delay(1000L)
    }
    delay(1000L)          // ①
    job.log()
    job.start()           // ②
    job.log()
    delay(1500L)          // ③
    job.log()
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = false
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
Coroutine start!
Thread:main @coroutine#3
================================
================================
isActive = false
isCancelled = false
isCompleted = true
Thread:main @coroutine#2
================================
</code></pre>
<p>上面代码我们在创建协程的时候将 start 参数设置成了 <strong>LAZY</strong>，这样创建协程时就不会启动了。</p>
<p>然后延迟了 1 秒钟，查看了一下协程的状态，会发现 <strong>isActive</strong> 是 false，<strong>isCompleted</strong> 也是 false。</p>
<p>当我们调用了 Job 的 <code class="notranslate">start</code> 方法后，再次查看状态，<strong>isActive</strong> 变成了 true，并且协程中的任务也打印了 “Coroutine start!”，说明调了 <code class="notranslate">start</code> 方法之后会把协程激活。</p>
<p>又等了 1.5 秒后，协程也正常结束了。</p>
<h4>2. <strong>Job</strong> 的 <code class="notranslate">cancel</code> 方法：</h4>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test4() = runBlocking {
    val job = launch(start = CoroutineStart.LAZY) {
        logX("Coroutine start!")
        delay(1000L)
        logX("Coroutine end!")
    }
    delay(500L)
    job.log()
    job.start()
    job.log()
    delay(500L)           // ①
    job.cancel()          // ②
    job.log()             // ③
    delay(2000L)          // ④
    job.log()             // ⑤
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = false
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
Coroutine start!
Thread:main @coroutine#3
================================
================================
isActive = false
isCancelled = true
isCompleted = false
Thread:main @coroutine#2
================================
================================
isActive = false
isCancelled = true
isCompleted = true
Thread:main @coroutine#2
================================
</code></pre>
<p>我们还是创建了一个懒加载的协程，启动它 500 毫秒之后，调用了 <strong>Job</strong> 的 <code class="notranslate">cancel</code> 方法，这时去查看协程的状态，会发现 <strong>isActive</strong> 变成了 false，<strong>isCancelled</strong> 变成了 true。</p>
<p>等又过了 2 秒，我们再次查看协程的状态，发现 <strong>isCompleted</strong> 也变成了 true，并且最后协程任务中的 “Coroutine end!” 也没有打印出来。说明 <code class="notranslate">cancel</code> 方法会把协程任务取消掉。</p>
<p>到这里我们是不是发现 <strong>Job</strong> 也有个生命周期，没错，Job 的源码注释中就已经说明了：</p>
<p><img src="https://blog-image.ian2018.cn/images/02d149556182e6f048337afa6517fb40ab000c88.png"></p>
<p><img src="https://blog-image.ian2018.cn/images/617ccf573494e8efa04ebfd5d14927932b39cf00.png"></p>
<p>从上面我们就能清晰的看到整个 <strong>Job</strong> 的生命周期。</p>
<p>但是有个奇怪的点，上面代码执行结果出现了 <strong>isCancelled</strong> 和 <strong>isCompleted</strong> 同时都为 true 的情况，这在图中的生命周期是没有体现的。</p>
<p>这是因为，协程认为由于某种原因取消的协程，也仍然是一种“结束状态”。所以流程图当中的 New、Active、Completing、Cancelling、Completed、Cancelled 这些状态，其实都是 <strong>Job</strong> 内部私有的状态，而 <strong>Job</strong> 对外暴露出的 <strong>isCompleted</strong> 并不是与其一一对应的。</p>
<p>Android 中的 <code class="notranslate">lifecycleScope</code> 就是在 onDestroy 的时候，通过 <strong>Job</strong> 将协程 cancel 掉了，这才有了和 Activity/Fragment 生命周期绑定的 scope，所以大家创建协程的时候，尽量都用这个 scope，不要用全局的，除非这个任务就是需要全局运行的。</p>
<h3>三、测试通过 Job 等待协程运行</h3>
<h4>1. Job 的 join</h4>
<p>前面几个例子我们是都知道协程中的任务执行了多久，然后去查看协程的状态。但实际开发中我们一般都是不能提前知道的，就比如进行网络请求，这时候我们就可以用 <strong>Job</strong> 的 <code class="notranslate">join</code> 方法了。</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test5() = runBlocking {
    suspend fun download() {
        // 模拟下载任务
        val time = (Random.nextDouble() * 1000).toLong()
        logX("Delay time: = $time")
        delay(time)
    }

    val job = launch {
        logX("Coroutine start!")
        download()
        logX("Coroutine end!")
    }
    job.log()
    job.join()      // 等待协程执行完毕
    job.log()
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
Coroutine start!
Thread:main @coroutine#3
================================
================================
Delay time: = 456
Thread:main @coroutine#3
================================
================================
Coroutine end!
Thread:main @coroutine#3
================================
================================
isActive = false
isCancelled = false
isCompleted = true
Thread:main @coroutine#2
================================
</code></pre>
<p><code class="notranslate">join</code> 是个挂起函数，所以执行到 join 那里会把代码挂起，等协程运行完成后，后面的代码才会继续执行。</p>
<p>另外我们还可以通过给 <strong>Job</strong> 添加一个通知回调的方式，来知道协程运行完成，这可以使用 <strong>Job</strong> 的 <code class="notranslate">invokeOnCompletion</code>：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test6() = runBlocking {
    suspend fun download() {
        // 模拟下载任务
        val time = (Random.nextDouble() * 1000).toLong()
        logX("Delay time: = $time")
        delay(time)
    }

    val job = launch {
        logX("Coroutine start!")
        download()
        logX("Coroutine end!")
    }
    job.log()
    job.invokeOnCompletion {
        job.log()   // 协程结束以后就会调用这里的代码
    }
    job.join()      // 等待协程执行完毕
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
Coroutine start!
Thread:main @coroutine#3
================================
================================
Delay time: = 170
Thread:main @coroutine#3
================================
================================
Coroutine end!
Thread:main @coroutine#3
================================
================================
isActive = false
isCancelled = false
isCompleted = true
Thread:main @coroutine#3
================================
</code></pre>
<p>可以看到效果是一样的，这样我们就能在代码其他地方来监听协程的运行了。</p>
<p>但是需要注意的是，协程被 <code class="notranslate">cancel</code> 了也同样会回调：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test6() = runBlocking {
    suspend fun download() {
        // 模拟下载任务
        val time = (Random.nextDouble() * 1000).toLong()
        logX("Delay time: = $time")
        delay(time)
    }

    val job = launch {
        logX("Coroutine start!")
        download()
        logX("Coroutine end!")
    }
    job.log()
    job.invokeOnCompletion {
        job.log()   // 协程结束以后就会调用这里的代码
    }
    job.cancel()    // 取消协程
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
isActive = true
isCancelled = false
isCompleted = false
Thread:main @coroutine#2
================================
================================
isActive = false
isCancelled = true
isCompleted = true
Thread:main @coroutine#3
================================
</code></pre>
<h4>2. Deferred 的 await</h4>
<p><strong>Deferred</strong> 继承了 <strong>Job</strong> 但只比 <strong>Job</strong> 多了一个 <code class="notranslate">await</code> 方法：<br>
<img src="https://blog-image.ian2018.cn/images/21f6a4af8d7d547f837157d606f3a0a33d2d4c15.png"></p>
<p>和 <code class="notranslate">join</code> 类似，<code class="notranslate">await</code> 也是可以等待协程运行完成，只不过 <code class="notranslate">await</code> 是有返回值的，可以拿到协程的运行结果：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test7() = runBlocking {
    suspend fun download(): String {
        // 模拟下载任务
        val time = (Random.nextDouble() * 1000).toLong()
        logX("Delay time: = $time")
        delay(time)
        return "download result!"
    }
    
    val deferred = async {
        logX("Coroutine start!")
        val result = download()
        logX("Coroutine end!")
        return@async result
    }
    val result = deferred.await()
    println("Result = $result")
    logX("Process end!")
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
Coroutine start!
Thread:main @coroutine#3
================================
================================
Delay time: = 263
Thread:main @coroutine#3
================================
================================
Coroutine end!
Thread:main @coroutine#3
================================
Result = download result!
================================
Process end!
Thread:main @coroutine#2
================================
</code></pre>
<p><code class="notranslate">await</code> 也是一个挂起函数，通过 <code class="notranslate">await</code> 我们拿到了 <code class="notranslate">async</code> 协程的运行结果。这里可以再回忆一下挂起函数的运行模型：<br>
<img src="https://blog-image.ian2018.cn/images/845ae9cde2593556965e11f079cdf3146bb1cea2.gif"></p>
<p>通过上面几个例子我们应该已经知道了 <strong>Job</strong> 有什么用了吧，其实 <strong>Job</strong> 就是用来控制协程的，也就是 <strong>Job</strong> 是协程的句柄。这里可以类比遥控器和空调的关系：</p>
<ul>
<li>空调遥控器可以监测空调的运行状态；Job 也可以监测协程的运行状态；</li>
<li>空调遥控器可以操控空调的运行状态，Job 也可以简单操控协程的运行状态。</li>
</ul>
<p>那么现在 <strong>Job</strong> 还剩最后一块「parent-child」，下面我们来看看这个父子关系到底是什么？</p>
<h2>结构化并发</h2>
<p><strong>Job</strong> 中的 <code class="notranslate">children</code> 其实是和结构化并发有关的，这也是协程的另一大特色。那么什么是结构化并发呢？从字面上看就是有结构的并发（废话文学了🙄），还是看几个例子吧：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test8() = runBlocking {
    val parentJob: Job
    var job1: Job? = null
    var job2: Job? = null
    var job3: Job? = null
    parentJob = launch {
        job1 = launch {
            delay(1000L)
        }
        job2 = launch {
            delay(3000L)
        }
        job3 = launch {
            delay(5000L)
        }
    }
    delay(500L)
    parentJob.children.forEachIndexed { index, job -&gt;
        when (index) {
            0 -&gt; println("job1 === job is ${job1 === job}")
            1 -&gt; println("job2 === job is ${job2 === job}")
            2 -&gt; println("job3 === job is ${job3 === job}")
        }
    }
    parentJob.join() // 这里会挂起大约5秒钟
    logX("Process end!")
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">job1 === job is true
job2 === job is true
job3 === job is true
================================
Process end!
Thread:main @coroutine#2
================================
</code></pre>
<p>上面代码中我们在一个 launch 块中又创建了 3 个 launch，得到了 parentJob 和 job 1-3，然后比较了 parentJob 的 children 和 job 1-3 是否相等。从结果上看，它们就是同一个对象，也就是 launch 创建的协程是有父子关系的，它们结构大概是下面这样：<br>
<img src="https://blog-image.ian2018.cn/images/18b29a89ce5307f9a9e28ddf5a262e5c2e038175.png"></p>
<p>还有 parentJob 执行 join 的时候大概挂起了 5 秒，而子协程中最长的任务就是 5 秒，这说明父协程会等所有子协程全部完成后，才会结束：<br>
<img src="https://blog-image.ian2018.cn/images/08a9b255f24248d65e4e90828fc1ffaebc492437.gif"></p>
<p>然后我们再试试 cancel 的情况：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test9() = runBlocking {
    val parentJob: Job
    var job1: Job? = null
    var job2: Job? = null
    var job3: Job? = null
    parentJob = launch {
        job1 = launch {
            logX("Job1 start!")
            delay(1000L)
            logX("Job1 done!") // ①，不会执行
        }
        job2 = launch {
            logX("Job2 start!")
            delay(3000L)
            logX("Job2 done!") // ②，不会执行
        }
        job3 = launch {
            logX("Job3 start!")
            delay(5000L)
            logX("Job3 done!")// ③，不会执行
        }
    }
    delay(500L)
    parentJob.children.forEachIndexed { index, job -&gt;
        when (index) {
            0 -&gt; println("job1 === job is ${job1 === job}")
            1 -&gt; println("job2 === job is ${job2 === job}")
            2 -&gt; println("job3 === job is ${job3 === job}")
        }
    }
    parentJob.cancel() // 变化在这里
    logX("Process end!")
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">================================
Job1 start!
Thread:main @coroutine#4
================================
================================
Job2 start!
Thread:main @coroutine#5
================================
================================
Job3 start!
Thread:main @coroutine#6
================================
job1 === job is true
job2 === job is true
job3 === job is true
================================
Process end!
Thread:main @coroutine#2
================================
</code></pre>
<p>上面代码我们调用了 parentJob 的 <code class="notranslate">cancel</code>，会发现直到整个程序结束了 job 1-3 也不会执行结束。说明父协程取消了，连带所有的子协程也会跟着取消：<br>
<img src="https://blog-image.ian2018.cn/images/be55bf136e50c207113f77878f5e10f81db62c3d.gif"></p>
<p>到这差不多能理解什么是结构化并发了吧，就是带有结构和层级的并发。接下来我们举几个比较实用的例子。</p>
<h2>实际应用</h2>
<p>需求大概是这样的：一个照片详情页，有三个接口，分别是获取照片详情信息、获取照片点赞列表、获取照片评论列表，这三个接口之前没有耦合，只有三个接口全都获取到信息才能进行 UI 展示。</p>
<p>我们先看一下一般写法：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test10() = runBlocking {
    suspend fun getPhotoInfo(): String {
        delay(1000L) // 模拟耗时操作
        return "photo info"
    }
    suspend fun getPhotoLikeList(): String {
        delay(1000L) // 模拟耗时操作
        return "photo like list"
    }
    suspend fun getPhotoCommentList(): String {
        delay(1000L) // 模拟耗时操作
        return "photo comment list"
    }

    val deferred = async {
        val results = mutableListOf&lt;String&gt;()
        // measureTimeMillis 是 kotlin 里一个统计执行时间的方法
        val time = measureTimeMillis {
            results.add(getPhotoInfo())
            results.add(getPhotoLikeList())
            results.add(getPhotoCommentList())
        }
        println("Cost Time: $time")
        results
    }
    
    println("开始展示 UI: ${deferred.await()}")
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">Cost Time: 3015
开始展示 UI: [photo info, photo like list, photo comment list]
</code></pre>
<p>我们写了 3 个挂起函数模拟 3 个接口的请求，然后直接在协程里就去分别请求了，大概消耗 3 秒才结束。</p>
<p>然后我们看一下优化后的：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test11() = runBlocking {
    suspend fun getPhotoInfo(): String {
        delay(1000L) // 模拟耗时操作
        return "photo info"
    }
    suspend fun getPhotoLikeList(): String {
        delay(1000L) // 模拟耗时操作
        return "photo like list"
    }
    suspend fun getPhotoCommentList(): String {
        delay(1000L) // 模拟耗时操作
        return "photo comment list"
    }

    val deferred = async {
        val results: List&lt;String&gt;
        // measureTimeMillis 是 kotlin 里一个统计执行时间的方法
        val time = measureTimeMillis {
            // 里面也用 async 并行请求
            val result1 = async { getPhotoInfo() } 
            val result2 = async { getPhotoLikeList() }
            val result3 = async { getPhotoCommentList() }
            results = listOf(result1.await(), result2.await(), result3.await())
        }
        println("Cost Time: $time")
        results
    }
    
    println("开始展示 UI: ${deferred.await()}")
}
</code></pre>
<p>打印结果：</p>
<pre class="notranslate"><code class="notranslate">Cost Time: 1022
开始展示 UI: [photo info, photo like list, photo comment list]
</code></pre>
<p>可以看到消耗的时间变成 1 秒，大大提升了运行效率。</p>
<p>所有当异步任务之间没有互相依赖时，可以通过这样的结构化并发来优化代码运行效率。实际上，<code class="notranslate">async</code> 最常见的使用场景就是与挂起函数结合，优化并发。</p>
<h2>结束了</h2>
<p>到这我们应该已经清楚了 <strong>Job</strong> 是什么，能干什么用了。主要就是「<strong>监控控制协程运行</strong>」和处理「<strong>结构化并发</strong>」。</p>
<p>最后说一下 cancel 的一个坑，看下面代码猜运行结果：</p>
<pre class="notranslate"><code class="notranslate">fun test12() = runBlocking {

    suspend fun fetchAll() {
        withContext(Dispatchers.IO) {
            var i = 0
            while (true) {
                i++
                logX("fetch i: $i")
            }
        }
    }

    val job = launch {
        logX("coroutine start!")
        fetchAll()
        logX("coroutine end!")
    }

    delay(500L)

    job.cancel()

    logX("Process end!")
}
</code></pre>
<p>这段代码其实是不会结束的，因为 fetchAll 里没有处理协程 cancel 的情况，所有会一直运行。因为 cancel 只是改变了状态，取消的话还需要协程内部去配合。</p>
<p>之前那些例子能取消，是因为那里面用了 <code class="notranslate">delay</code> 这个方法，是 <code class="notranslate">delay</code> 方法里处理了 cancel，并抛出了一个取消的异常，所以协程才能结束。</p>
<p>解决办法就是在协程里加上当前状态的判断：</p>
<pre lang="kotlin" class="notranslate"><code class="notranslate">fun test12() = runBlocking {

    suspend fun fetchAll() {
        withContext(Dispatchers.IO) {
            var i = 0
            while (isActive) { // 变化在这里
                i++
                logX("fetch i: $i")
            }
        }
    }

    val job = launch {
        logX("coroutine start!")
        fetchAll()
        logX("coroutine end!")
    }

    delay(500L)

    job.cancel()

    logX("Process end!")
}
</code></pre>
<p>这样我们自己定义的挂起函数也能响应 cancel 了。</p>
<hr>
<p>最最后再推荐一下极客时间的《Kotlin 编程第一课》，上面的内容都是参考的这门课程。</p>
</div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</br></br><span>❤️ 感谢 <span id="user-content-page_uv"></span> 位小伙伴的 <span id="user-content-page_pv"></span> 次访问该文章。</span></br></br></div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://blog.ian2018.club"> IAn2018cs </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if("08/31/2016"!=""){
    var now=new Date();
    var startSite=new Date("08/31/2016");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek v2.19 https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","chenshuais/chenshuais.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>
<script async src='//blog-image.ian2018.cn/webviso.min.js' data-page-pv-id='user-content-page_pv' data-page-uv-id='user-content-page_uv'></script>

</html>
